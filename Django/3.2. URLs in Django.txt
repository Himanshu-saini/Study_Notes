Defining URLs
===============

- polls/urls.py
  --------------
  from django.urls import path
  from . import views

  urlpatterns = [
    path('', views.index, name='index'),
  ]

Use of path()
-------------
- Patterns in path() don’t search GET and POST parameters, or the domain name.
- When Django finds a matching pattern, 
  it calls the specified view function with an HttpRequest object as the first argument
- The path() function is passed four arguments, 
  - Two required: route and view
    - route : match the url
	- view : function to call when the url is matched
  - Two optional: kwargs, and name
    - kwargs
      Arbitrary keyword arguments can be passed in a dictionary to the target view
    - name
      Naming your URL lets you refer to it unambiguously from elsewhere in Django, especially from within templates.

Regular expression pattern matching
-------------------------------------
- Re_path():
  Re_path(r”^/index$”,view.index)

Using include()
----------------
- Whenever Django encounters include(), 
  it chops off whatever part of the URL matched up to that point 
  and sends the remaining string to the included URLconf for further processing.
- mysite/urls.py
  --------------
  from django.contrib import admin
  from django.urls import include, path

  urlpatterns = [
    path('polls/', include('polls.urls')),
    path('admin/', admin.site.urls),
  ]


===================
Features of URLconf
===================
- There’s no need to add a leading slash, because every URL has that. 
  For example, it’s "articles", not "/articles"

======================== 
Capture value for URL
========================
- To capture a value from the URL, use angle brackets
  which sends it as a keyword argument to the view function. 
- Captured values can optionally include a converter type. 

- Exaple: <int:question_id>
  The ":question_id>" part of the string defines 
  the name that will be used to identify the matched pattern, 
  and the "<int:" part is a converter that determines 
  what patterns should match this part of the URL path.
- If a converter isn’t included, any string, excluding a / character, is matched.

Path converters
---------------
- str :default
- int 
- slug 
- uuid 
- path - Matches any non-empty string, including the path separator, '/'

Using regular expressions
==========================
- If the paths and converters syntax isn’t sufficient for defining your URL patterns, 
  you can also use regular expressions. 
- To do so, use re_path() instead of path().
- Syntax for named regular expression groups is (?P<name>pattern), 
  where name is the name of the group and pattern is some pattern to match.

- Example:
  from django.urls import path, re_path
  from . import views

  urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    re_path(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
    re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$', views.month_archive),
    re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<slug>[\w-]+)/$', views.article_detail),
 ]

- Each captured argument is sent to the view as a string, 
  regardless of what sort of match the regular expression makes.

Nested arguments
-----------------
- re_path(r'^comments/(?:page-(?P<page_number>\d+)/)?$', comments)
  The outer argument in this case is a non-capturing argument (?:...)

Using custom path converters
====================================
- A converter is a class that includes the following:
  - A regex class attribute, as a string.
  - A to_python(self, value) method, 
    which handles converting the matched string into the type 
	that should be passed to the view function. 
	It should raise ValueError if it can’t convert the given value. 
  - A to_url(self, value) method, 
    which handles converting the Python type into a string to be used in the URL.

- For example:
  class FourDigitYearConverter:
    regex = '[0-9]{4}'
    def to_python(self, value):
        return int(value)
    def to_url(self, value):
        return '%04d' % value

Register custom converter classes in your URLconf using register_converter():
-------------------------------------------------------------------------------
  from django.urls import path, register_converter
  from . import converters, views

  register_converter(converters.FourDigitYearConverter, 'yyyy')

  urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    path('articles/<yyyy:year>/', views.year_archive),
    ...
  ]

=========================================
Passing extra options to view functions
=========================================
- The path() function can take an optional third argument 
  which should be a dictionary of extra keyword arguments to pass to the view
- For example:
  from django.urls import path
  from . import views

  urlpatterns = [
    path('blog/<int:year>/', views.year_archive, {'foo': 'bar'}),
  ]

Passing extra options to include()
----------------------------------
- Similarly, you can pass extra options to include() 
  and each line in the included URLconf will be passed the extra options. 
  # main.py
  from django.urls import include, path
  urlpatterns = [
    path('blog/', include('inner'), {'blog_id': 3}),
  ]

===========================
Reverse resolution of URLs
===========================
- Django provides tools for performing URL reversing 
  that match the different layers where URLs are needed:
- In templates: Using the url template tag.
- In Python code: Using the reverse() function.
- In higher level code related to handling of URLs of Django model instances: The get_absolute_url() method.

- Exaple URLconf entry:
  from django.urls import path
  from . import views

  urlpatterns = [
    #...
    path('articles/<int:year>/', views.year_archive, name='news-year-archive'),
    #...
  ]

- You can obtain these in template code by using:
  <a href="{% url 'news-year-archive' 2012 %}">2012 Archive</a>
  OR
  {# Or with the year in a template context variable: #}
  <ul>
  {% for yearvar in year_list %}
  <li><a href="{% url 'news-year-archive' yearvar %}">{{ yearvar }} Archive</a></li>
  {% endfor %}
  </ul>

- Using in Python code:
  from django.http import HttpResponseRedirect
  from django.urls import reverse

  def redirect_to_year(request):
    # ...
    year = 2006
    # ...
    return HttpResponseRedirect(reverse('news-year-archive', args=(year,)))

URL namespaces
================
- A URL namespace comes in two parts, both of which are strings: 
  - application namespace
    This describes the name of the application that is being deployed.
  - instance namespace
    This identifies a specific instance of an application

- Namespaced URLs are specified using the ':' 
- For example 
  the main index page of the admin application is referenced using 'admin:index'. 
  This indicates a namespace of 'admin', and a named URL of 'index'.
- Namespaces can also be nested. The named URL 'sports:polls:index'

Method 1
------------
- you can set an app_name attribute in the included URLconf module, 
  at the same level as the urlpatterns attribute.

  polls/urls.py
  -------------
  from django.urls import path
  from . import views

  app_name = 'polls'
  urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    ...
  ]

- Match using polls:index or polls:detail

Method 2:
----------
- urls.py
  --------
  from django.urls import include, path

  urlpatterns = [
    path('author-polls/', include('polls.urls', namespace='author-polls')),
    path('publisher-polls/', include('polls.urls', namespace='publisher-polls')),
  ]

- polls/urls.py
  --------------
  from django.urls import path
  from . import views

  app_name = 'polls'
  urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    ...
  ]
- Match using aurther-polls:index

