================================
Important Features of Javasrcipt
=================================

Type Coercion
=============
- process of converting value from one type to another 
- Ex.
  a = "3" + 2 // a becomes "32"
  - integer is converted to string and added
  "234" == 234 // True
  - integer is converted to string 

Hoisting 
========
- Hoisting was thought up as a general way of thinking about 
  how execution contexts (specifically the creation and 
  execution phases) work in JavaScript.

- strict definition of hoisting suggests that 
  variable and function declarations are physically moved 
  to the top of your code
  but this is not in fact what happens
- variable and function declarations are put into memory 
  during the compile phase, but stay exactly 
  where you typed them in your code.

- Advantages
  -----------
  - it allows you to use a function before you declare it in your code.
  - The variables can be initialized and used before they are declared.
    - JavaScript only hoists declarations, not initializations
	- Ex 
	  console.log(num);  // print undefined, but not ReferenceError
	  var num = 5;
	- Declarations using let and const are also not hoisted. 
	- Ex 
	  console.log(num);  // Throws ReferenceError exception 
	  let num;
	- Variable Hoisting is not done 
	  if there is no varible declaration line only initialization is done.
    - Ex 
	  console.log(num);  // Throws ReferenceError exception 
	  num = 5;  // Variable id declared when initialized but hoisting is not done

Scope Chain
===========
- When a variable is used in JavaScript, 
  the JavaScript engine will try to find the variableâ€™s value 
  in the current scope. If it could not find the variable, 
  it will look into the outer scope and will continue to do so 
  until it finds the variable or reaches global scope.
- Ex.
  var name = "Global";
  
  function fun1(){
    var name = "fun1";
    console.log(`In fun1 scope name is ${name}`)  // prints fun1
    function fun2(){
      console.log(`In fun2 scope name is ${name}`)  // prints fun1
    }
    fun2(); 
  }
  fun1();
  console.log(`In global scope name is ${name}`)  // prints Global

Lexical Environment
=====================
- structure that holds identifier-variable mapping
  - place where variables and references to the objects are stored.
- A new lexical environment is created for each lexical scope 
  but only when the code in that scope is executed.
- Ex. 
  lexicalEnvironment = {
    a: 25,
    obj: <ref. to the object>
    outer: <outer lexical environemt>  // null in case of global 
  }

lexical scope
-------------
- a scope that is determined at compile time
