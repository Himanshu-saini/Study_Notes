=================
Serializer in DRF
=================

- Using SerializerMethodField
  - read only field that computes its value at request processing time
    by calling a method on the serializer class it is attached to.
  - SerializerMethodField accepts method_name, defualt = get_<field_name> (prefered)
  - Change the way a field is represented in API response
  - Ex 
  class TagSerializer(serializers.ModelSerializer):
    created = serializers.SerializerMethodField()

    class Meta:
        model = Tag
        fields = ('label', 'created')

    def get_created(self, obj):
      return round(obj.created.timestamp())

- source parameter
  - rename field name in API response 
  - job_type = serializers.CharField(source='task_type')
    - task_type in Model will be represented as job_type in API 
  - fetch data from related objects using dotted notation
    owner_email = serializers.CharField(source='owner.email')
	
- Serializer field validation
  - decouples different checks that are related only to a particular field
  - generates well formatted error responses
  - method naming convention: def validate_<field_name>
  - Ex  
    class TransactionSerializer(serializers.ModelSerializer):
      bid = serializers.IntegerField()

	  def validate_bid(self, bid: int) -> int:
        if bid > self.context['request'].user.available_balance:
            raise serializers.ValidationError(
                _('Bid is greater than your balance')
            )
      return bid
  - Validation methods must always return a value
  - field level validation is invoked by serializer.to_internal_value(), 
    which takes place before calling serializer.validate().

- Passing a value directly to the save method
  - to pass a value from outside of a serializer directly to its save() method
  - take arguments that can be equated with serialized objects
  - Values passed this way won’t be validated
  - Ex 
    serializer = EmailSerializer(data=request.data)
    serializer.is_valid(raise_exception=True)
    serializer.save(owner_id=request.user.id)

- Using CurrentUserDefault
  - automatically setting a user as a resource owner
  - CurrentUserDefault class, which doesn’t require any override of views.
  - class EmailSerializer(serializers.ModelSerializer):
    owner = serializers.HiddenField(
        default=serializers.CurrentUserDefault()
    )
	# Owner = field name 

  - user authenticated in the request object will be set as default
  - because of using HiddenField, any incoming data is not taken into account
    so it’s impossible to set another user as an owner

- Serializers initial data
  - data before modified by running serializer.is_valid()
  - before validated_data is available 
  - serializer.initial_data which stores raw input as a Dict
  - Ex 
    class SignupSerializer(serializers.ModelSerializer):
      password1 = serializers.CharField()
      password2 = serializers.CharField()

	  def validate_password1(self, password1):
      if password1 != self.initial_data['password2']:
        raise serializers.ValidationError(
            'Passwords do not match'
        )